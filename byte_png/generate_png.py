import os
import torch
from PIL import Image
from torch.multiprocessing import Pool, set_start_method
def bytes_to_binary(bytefile):

    with open(bytefile, 'rb') as f:
        content = f.read()
    binary = ''.join(format(byte, '08b') for byte in content)
    return binary

def binary_to_rgb(binary_data):

    pixels = []

    for i in range(0, len(binary_data), 8):
        chunk = binary_data[i:i+8]
        decimal = int(chunk, 2)
        pixels.append(decimal)
    
    RGB = [(pixels[i], pixels[i + 1], pixels[i + 2]) for i in range(0, len(pixels) - 2, 3)]
    return RGB

def save_rgb_as_image(RGB, filename):
    """Save RGB data as an image."""
    image = Image.new('RGB', (224, 224))
    pixels = image.load()
    
    idx = 0
    for i in range(224):
        for j in range(224):
            if idx < len(RGB):
                pixels[j, i] = RGB[idx]
                idx += 1
            else:
                pixels[j, i] = (0, 0, 0)  # Black padding
                
    image.save(filename)
from functools import partial
def process_file(input_dir, output_dir, file):
    if file.endswith(".bytes"):
        binary_data = bytes_to_binary(os.path.join(input_dir, file))

        for offset in range(8):
            adjusted_binary = binary_data[offset:]
            RGB = binary_to_rgb(adjusted_binary)
            
            base_filename = os.path.splitext(file)[0]
            save_dir = os.path.join(output_dir, base_filename)

            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            
            output_filename = os.path.join(save_dir, f"{base_filename}{offset + 1}.png")
            save_rgb_as_image(RGB, output_filename)

from tqdm import tqdm

def main():
    input_dir = "Big2015/data"
    output_dir = "byte_png"
    
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    num_processes = os.cpu_count()

    # Make sure CUDA initialization works with multiprocessing
    set_start_method('spawn')

    # Partially apply the input and output directories
    func = partial(process_file, input_dir, output_dir)
    
    # Use this partial function as the target for imap
    with Pool(num_processes) as p:
        for _ in tqdm(p.imap(func, os.listdir(input_dir)), total=len(os.listdir(input_dir))):
            pass

if __name__ == "__main__":
    main()